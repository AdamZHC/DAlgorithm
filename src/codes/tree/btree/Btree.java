package codes.tree.btree;

public class Btree {
    //局部B -> 整体B 和那个 平衡树的最小失衡树有异曲同工之妙，就是每次插入都保证局部的B,最后再去保证整体B,
    //但是区别在于这样：平衡树的插入过程是，插入之后保证据局部平衡之后整体一定平衡，但是B树的操作是保证局部平衡之后
    //有可能导致上层的或者说整体的树不平衡，这是需要再去调整，注意这时应该往上一层去调整，整体的思路是这样的，但是具体实现，现在还是做不来
    //B树的若干特点：
    /*
     * 1.叶子结点均在一层
     * 2.多结点要么无子节点，要么满子节点
     * 3.仍然是排序树，并且符合规则，是平衡树（所有子节点都在一层）
     * B树的阶是最多子结点的个数，还有就是结合二分查找
     * B+树的数据只存放在叶子结点，叶子结点实现方式是链表，类似于哈希表，稠密索引
     * B*树可以用索引相指向
     * */
}
